<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Kardusen664.github.io</id>
    <title>喵屋</title>
    <updated>2021-05-19T12:54:57.145Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Kardusen664.github.io"/>
    <link rel="self" href="https://Kardusen664.github.io/atom.xml"/>
    <subtitle>刺猬和狐狸的窝</subtitle>
    <logo>https://Kardusen664.github.io/images/avatar.png</logo>
    <icon>https://Kardusen664.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 喵屋</rights>
    <entry>
        <title type="html"><![CDATA[BST]]></title>
        <id>https://Kardusen664.github.io/post/bst/</id>
        <link href="https://Kardusen664.github.io/post/bst/">
        </link>
        <updated>2020-09-12T17:23:05.000Z</updated>
        <content type="html"><![CDATA[<p>123</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无处安放的小知识]]></title>
        <id>https://Kardusen664.github.io/post/wu-chu-an-fang-de-xiao-zhi-shi/</id>
        <link href="https://Kardusen664.github.io/post/wu-chu-an-fang-de-xiao-zhi-shi/">
        </link>
        <updated>2020-09-09T12:56:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.typedef<br>
①为特定含义的类型<em>取别名</em><br>
eg.typedef long long ll;<br>
好处：在修改元素类型的时候可以只修改一处；可以直截了当的得知变量的含义；<s>方便写</s>；<br>
②为结构体取别名。<br>
<em>不过有的人认为这样做并不是一个明智的选择，因为它在使用的时候不能<strong>直观</strong>看到它是结构体类型了。</em></p>
<pre><code>struct node{
    int l; int r; int val;
};
</code></pre>
<p>那么你在声明变量的时候，需要带上struct, 即：<br>
<code>struct node a[maxn + 5];</code><br>
但是如果你用typedef取个别名呢？</p>
<pre><code>typedef struct node
{
    int l; int r; int val;
} Treenode; 
</code></pre>
<p>你就可以这样使用了：<br>
<code>Treenode a[maxn +5]</code></p>
<p>一句话理解：typedef中声明的类型在变量名的位置出现。</p>
<p>2.class 和 struct 没有什么不同，只不过：<br>
①class的类型默认是private, struct的类型默认是public<br>
②在class中可以编写对象的<strong>行为</strong>，也就是函数。</p>
<p>3.面向对象和面向过程<br>
<em>浇盖饭与蛋炒饭</em></p>
<p>4.三目运算符<br>
三目运算符是<strong>一个固定格式格式为？：的语句</strong><br>
结构为&lt;表达式1&gt;？&lt;表达式2&gt;：&lt;表达式3&gt;<br>
如果第一个表达式为真，那么就做问号后面的语句，不然就做最后的语句</p>
<p>5.c++中switch语句的语法：<br>
①在一个switch中可以有任意数量的case语句。每个case后跟一个要比较的值和一个冒号。<br>
②当（）时，case后的语句被执行，直到遇到break语句为止。<br>
③当遇到break语句时，switch终止，控制流将跳转到<em>switch语句后</em>的下一行，<br>
④不是每一个case都需要包含break。如果case语句不包含break，控制流将会<em>继续后续的case，直到遇到break为止。</em><br>
⑤一个switch语句可以有一个可选的<strong>default</strong>语句，出现在switch的结尾。<strong>default case</strong>可用于在上面<strong>所有case都不为真</strong>时执行一个任务。</p>
<pre><code>    switch(a){
        case 1:
            ...
            break;
        case2:
        default
    }
    ```
6.c++传值和传引用
</code></pre>
<p>void fun_1(int a);      //int类型，传值（复制产生新变量）<br>
void fun_2(int&amp; a);     //int类型，传引用（形参和实参是同一个东西）<br>
void fun_3(int* arr);   //指针类型，传值（复制产生新变量）<br>
void fun_4(int*&amp; arr);  //指针类型，传引用（形参和实参是同一个东西）</p>
<pre><code>7.逻辑运算符优先级问题
   1.*和&amp;的优先级相同，**具有右结合性**。
   2.逻辑且运算&amp;&amp;的优先级比或运算||高。

8.多组数据的处理:
while(**~**scanf(...))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序]]></title>
        <id>https://Kardusen664.github.io/post/pai-xu/</id>
        <link href="https://Kardusen664.github.io/post/pai-xu/">
        </link>
        <updated>2020-09-07T04:21:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1龟速三兄弟">1.龟速三兄弟</h2>
<p>①.冒泡排序<br>
如这个排序的名字一样，冒泡排序就是：从末尾一个数开始，两两<strong>比较</strong>，从而得出最小的数，最小的数<br>
就像泡泡那样冒上来，依次得出第二小的数、第三小的数...直至排序完毕。</p>
<p>②.选择排序<br>
又如这个排序一样，选择排序的原理是固定一个位置，让该位置的数与其他数进行<strong>比较</strong>来争夺这个位置，从而最小的数被选择出来，依此类推直至排序完毕。</p>
<p>③.插入排序<br>
在玩扑克牌时，我们总是希望手中的牌是有序的，每当摸到一张新牌，我们总是会和前面有序的牌组两两<strong>比较</strong>，然后插入序列中。</p>
<p>插入排序便是基于这样一种思想，把第1个数作为一个有序的序列，依次将第2、第3...第n个数插入到有序的序列中，就完成了插入排序的过程。<br>
代码：<br>
<img src="https://Kardusen664.github.io/post-images/1599455088518.png" alt="" loading="lazy"></p>
<p>##2.很妙的排序<br>
①.希尔排序<br>
希尔排序是<strong>插入排序的优化版本</strong>，我们知道插入排序在序列是<strong>有序</strong>的时候的效率是很高的(break语句的效用)，所以我们希望在进行插入排序的时候，数组能尽量有序，于是就有了希尔排序。</p>
<p>希尔排序中有一个增量delta，像我们小时候的跳石子游戏一样，增量delta将序列划分成为若干个子序列(具体是i, i+delta, i+2delta, ..为一个子序列)，对每个子序列进行插入排序，当delta缩成1的时候，此时的插入排序就是整个序列的排序。</p>
<p>那么怎么样才能让每一次进行插入排序的序列相对有序？关键在<strong>delta的值</strong>上：只要我们定delta的值为n/2，再在每一轮将delta的值除以2，就可以尽量保证序列相对有序。</p>
<p>代码：<br>
<img src="https://Kardusen664.github.io/post-images/1599456157356.png" alt="" loading="lazy"></p>
<p>②归并排序<br>
归并排序运用<strong>分治</strong>的思想，将序列分成最小的一份之后，再根据大小关系将两个子序列合并，当合并的得到的序列长度为原序列时，排序结束。<br>
由于其核心思想是分治，所以可以把排序分成两个部分完成。</p>
<ol>
<li>Divide<br>
<img src="https://Kardusen664.github.io/post-images/1599521474132.png" alt="" loading="lazy"></li>
<li>Merge<br>
<img src="https://Kardusen664.github.io/post-images/1599551791485.png" alt="" loading="lazy"></li>
</ol>
<p>③快速排序</p>
<p>④桶排序<br>
计数排序<br>
把数字直接放入对应的桶中，再从桶中倒出序列。<br>
优点是<strong>耗时短，时间复杂度接近O(n)。</strong><br>
缺点就是<strong>所需空间和数据大小有关</strong>，当数据很大的时候，所需空间太大</p>
<p>基数排序<br>
通过多次桶排序来进行排序，同时减少空间损耗。<br>
以以10为基数的基数排序举例：<br>
1).求出最大值，得出最长位数。<br>
2).由低到高位进行桶排<br>
取关键值digit→将数据放入桶中→按顺序将值提出回数组中<br>
不断执行如下过程直至进行至最高位。<br>
<strong>未改进的</strong>基数排序在面对位数不太大的数据的时候有优势。</p>
<p>⑤堆排序<br>
堆排序是依据数据结构堆的排序算法，包含堆的三个操作：<strong>建立，插入和删除</strong><br>
要想从堆中得到目标有序序列，只需不断的取出并删除堆顶元素，并维护剩下的堆。<br>
<strong>注意堆的节点中需要有一个num来标记该数据对应的序号</strong></p>
<p>##3.sort函数<br>
sort函数的模板有三个参数：<br>
(1)第一个参数first：是要麦序的数组的起始地址。<br>
(2)第二个参数last：是结束的地址(<strong>最后一个数据的后一个数据的地址</strong>)<br>
(3)第三个参数camp是排序的方法：<em>如果第三个参数不写，则默认的排序方式是从小到大排序</em>。</p>
<p>对于第三点：<br>
1.元素自身包含了比较关系，如int,double等基础类型，可以直接进行比较greater&lt;&gt;() (大小于括号内的是数据类型)。<br>
2.元素本身为class或struct，类内部需要重载&lt;运算符，实现元素的比较；</p>
<h1 id="问题">问题</h1>
<h2 id="1求第k大的数">1.求第k大的数。</h2>
<p>首先我们当然可以将数组排序然后输出，时间复杂度为O(nlogn)。<br>
<strong>优化</strong>：利用快速排序二分的思想，由于一次快排后数组将会分成三部分，其中左边比标准数小而右边大，<strong>所以第k小的值只会在一个区间里</strong>，从而只用查找那个区间，降低了时间复杂度。</p>
<pre><code>if(k∈[l. j]) qsort(i, j);
    else if(k∈[j,r]) qsort(j, r);
        else printf(&quot;%d&quot;, a[k]);
</code></pre>
<p>(由于k肯定在[l,r]里面，所以一半的边界可以省掉不写)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown应用指南]]></title>
        <id>https://Kardusen664.github.io/post/markdown-ying-yong-zhi-nan/</id>
        <link href="https://Kardusen664.github.io/post/markdown-ying-yong-zhi-nan/">
        </link>
        <updated>2020-09-04T02:37:22.000Z</updated>
        <content type="html"><![CDATA[<p><strong>对字的编辑</strong><br>
1.<strong>标题</strong></p>
<ul>
<li>一个#号为一级标题，两个#号为二级标题，依次类推。</li>
</ul>
<p>2.<strong>加粗/斜体</strong></p>
<ul>
<li>一个<em>号内的内容以斜体形式展示，两个</em>号内的内容为粗体，三个*号内的内容为粗斜体。</li>
</ul>
<p>3.<strong>删除线</strong>(划掉)</p>
<ul>
<li>在文字前后添加~~</li>
</ul>
<p><strong>对段的编辑</strong><br>
1.<strong>有序列表</strong></p>
<ul>
<li>在行首增加 1.、2.、3.，即数字和英文句点, 注意句点与文字中间有空格。</li>
</ul>
<p>2.<strong>无序列表</strong></p>
<ul>
<li>在行首添加*或-</li>
</ul>
<p>3.<strong>引用</strong></p>
<ul>
<li>在文字前添加' &gt;'</li>
</ul>
<p><strong>写代码</strong><br>
用```把代码框起来，就可以在里面使用tab缩进啦！</p>
<p><strong>划掉</strong><br>
<s>在文字前后加上两条波浪线</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://Kardusen664.github.io/post/test/</id>
        <link href="https://Kardusen664.github.io/post/test/">
        </link>
        <updated>2020-09-04T02:04:00.000Z</updated>
        <content type="html"><![CDATA[<p>202009041004</p>
<blockquote>
<p>2333<br>
引用</p>
</blockquote>
<p><em>歪了</em><br>
<strong>粗了</strong><br>
<code>#include&lt;cstdio&gt;</code></p>
<hr>
]]></content>
    </entry>
</feed>