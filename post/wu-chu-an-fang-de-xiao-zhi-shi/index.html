<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>无处安放的小知识 | 喵屋</title>
<link rel="shortcut icon" href="https://Kardusen664.github.io/favicon.ico?v=1621428785952">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Kardusen664.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="无处安放的小知识 | 喵屋 - Atom Feed" href="https://Kardusen664.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="1.typedef
①为特定含义的类型取别名
eg.typedef long long ll;
好处：在修改元素类型的时候可以只修改一处；可以直截了当的得知变量的含义；方便写；
②为结构体取别名。
不过有的人认为这样做并不是一个明智的选择，..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Kardusen664.github.io">
  <img class="avatar" src="https://Kardusen664.github.io/images/avatar.png?v=1621428785952" alt="">
  </a>
  <h1 class="site-title">
    喵屋
  </h1>
  <p class="site-description">
    刺猬和狐狸的窝
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              无处安放的小知识
            </h2>
            <div class="post-info">
              <span>
                2020-09-09
              </span>
              <span>
                3 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>1.typedef<br>
①为特定含义的类型<em>取别名</em><br>
eg.typedef long long ll;<br>
好处：在修改元素类型的时候可以只修改一处；可以直截了当的得知变量的含义；<s>方便写</s>；<br>
②为结构体取别名。<br>
<em>不过有的人认为这样做并不是一个明智的选择，因为它在使用的时候不能<strong>直观</strong>看到它是结构体类型了。</em></p>
<pre><code>struct node{
    int l; int r; int val;
};
</code></pre>
<p>那么你在声明变量的时候，需要带上struct, 即：<br>
<code>struct node a[maxn + 5];</code><br>
但是如果你用typedef取个别名呢？</p>
<pre><code>typedef struct node
{
    int l; int r; int val;
} Treenode; 
</code></pre>
<p>你就可以这样使用了：<br>
<code>Treenode a[maxn +5]</code></p>
<p>一句话理解：typedef中声明的类型在变量名的位置出现。</p>
<p>2.class 和 struct 没有什么不同，只不过：<br>
①class的类型默认是private, struct的类型默认是public<br>
②在class中可以编写对象的<strong>行为</strong>，也就是函数。</p>
<p>3.面向对象和面向过程<br>
<em>浇盖饭与蛋炒饭</em></p>
<p>4.三目运算符<br>
三目运算符是<strong>一个固定格式格式为？：的语句</strong><br>
结构为&lt;表达式1&gt;？&lt;表达式2&gt;：&lt;表达式3&gt;<br>
如果第一个表达式为真，那么就做问号后面的语句，不然就做最后的语句</p>
<p>5.c++中switch语句的语法：<br>
①在一个switch中可以有任意数量的case语句。每个case后跟一个要比较的值和一个冒号。<br>
②当（）时，case后的语句被执行，直到遇到break语句为止。<br>
③当遇到break语句时，switch终止，控制流将跳转到<em>switch语句后</em>的下一行，<br>
④不是每一个case都需要包含break。如果case语句不包含break，控制流将会<em>继续后续的case，直到遇到break为止。</em><br>
⑤一个switch语句可以有一个可选的<strong>default</strong>语句，出现在switch的结尾。<strong>default case</strong>可用于在上面<strong>所有case都不为真</strong>时执行一个任务。</p>
<pre><code>    switch(a){
        case 1:
            ...
            break;
        case2:
        default
    }
    ```
6.c++传值和传引用
</code></pre>
<p>void fun_1(int a);      //int类型，传值（复制产生新变量）<br>
void fun_2(int&amp; a);     //int类型，传引用（形参和实参是同一个东西）<br>
void fun_3(int* arr);   //指针类型，传值（复制产生新变量）<br>
void fun_4(int*&amp; arr);  //指针类型，传引用（形参和实参是同一个东西）</p>
<pre><code>7.逻辑运算符优先级问题
   1.*和&amp;的优先级相同，**具有右结合性**。
   2.逻辑且运算&amp;&amp;的优先级比或运算||高。

8.多组数据的处理:
while(**~**scanf(...))
</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Kardusen664.github.io/post/pai-xu/">
              <h3 class="post-title">
                排序
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://Kardusen664.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
